import { isNumeric } from "mathjs";
import { Util } from "./Util";
/**
     * @ngdoc service
     * @name $timeout
     *
     * @description
     * AngularJS's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
     * block and delegates any exceptions to
     * {@link ng.$exceptionHandler $exceptionHandler} service.
     *
     * The return value of calling `$timeout` is a promise, which will be resolved when
     * the delay has passed and the timeout function, if provided, is executed.
     *
     * To cancel a timeout request, call `$timeout.cancel(promise)`.
     *
     * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to
     * synchronously flush the queue of deferred functions.
     *
     * If you only want a promise that will be resolved after some specified delay
     * then you can call `$timeout` without the `fn` function.
     *
     * @param {function()=} fn A function, whose execution should be delayed.
     * @param {number=} [delay=0] Delay in milliseconds.
     * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
     *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
     * @param {...*=} Pass additional parameters to the executed function.
     * @returns {Promise} Promise that will be resolved when the timeout is reached. The promise
     *   will be resolved with the return value of the `fn` function.
     *
     */
export interface TimeoutPromise<T> extends Promise<T> 
{
  reject?: (reason?: any) => void; 
  $$timeoutId:NodeJS.Timeout | string | number | undefined,cancel:()=>void
}

export default function timeout<T>(fn:CallableFunction|number, delay:number=0, invokeApply:boolean|number=true) {
    if (isNumeric(fn)) {
      invokeApply = delay;
      delay = fn;
      fn = ()=>{};
    }

    const promise:TimeoutPromise<T> = {
      $$timeoutId: '',
      /**
       * @ngdoc method
       * @name $timeout#cancel
       *
       * @description
       * Cancels a task associated with the `promise`. As a result of this, the promise will be
       * resolved with a rejection.
       *
       * @param {Promise=} promise Promise returned by the `$timeout` function.
       * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
       *   canceled.
       */
      cancel: function () {
        if (!promise) return false;

        if (!Object.prototype.hasOwnProperty.call(promise, '$$timeoutId')) {
          throw '`timeout.cancel()` called with a promise that was not generated by `timeout()`.';
        }


        var id = promise.$$timeoutId;

        // Timeout cancels should not report an unhandled promise.
        clearTimeout(id);
        promise!.reject?.();
      },
      ...new Promise<T>((resolve, reject) => {
        promise.reject = reject;
        promise.$$timeoutId = setTimeout(
          () => {
            const res = (fn as CallableFunction)();
            resolve(res);
          },
          delay
        );
      }) as Promise<T>
    }

    
  /* return new Promise( (resolve,reject)=>{
    const cancel = setTimeout(
      ()=>{
        const res = (fn as CallableFunction)();
        resolve( res );
      },
      delay
    )
  }) */

  return promise;
};